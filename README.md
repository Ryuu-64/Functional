# Functional-Interface

## 这是什么？

此库包含 java 的预定义函数式接口及其多播函数式接口

### 函数式接口

预定义从无参到有参，从无返回值到有返回值的函数式接口 Action ~ Action3Arg 及 Func ~ Func5Arg。

(一般地，由于 java 类型签名未包含泛型参数，因此泛型参数不同的接口名称不得相同，因此不能像 C# 一样定义多个同名称，但泛型参不同的委托[1])

### 多播函数式接口

多播函数式接口是函数式接口的集合，对多播函数接口 invoke 将会 invoke 该集合中的所有函数式接口

支持添加、删除操作，支持 invoke 期间的并发添加及修改操作

(**java 不允许用户自定义运算符重载**，因此多播函数式接口的操作没有如 C# 中委托的 +、+=、- 及 -= 等语法糖)

## 有何好处？

复用此库中预设的函数式接口能减少系统中的类数量，简化代码。

其中多播函数式接口方便开发者基于事件进行编程。

## 详细

### java 函数式接口

### 不要定义过多的函数式接口

自 java 8 函数式接口 (functional interface) 特性加入后，开发者们很容易在有需要用到函数式接口的地方就声明一个新的函数式接口。

函数式接口最终越定越多，但他们大部分都是一样的，声明时都指定了特定的参数表参数数量、类型及返回值。

没有必要定义这么多函数式接口，一个特定类型的函数式接口定义一个就够了。

推荐复用此库中预设的函数式接口，而不是定义更多的函数式接口。这能减少系统中的类数量，简化代码。

(C# 同理，但 .NET 已将其封装，详情请见 [CSharp-委托](https://blog.ryuu64.top/CSharp-%E5%A7%94%E6%89%98/))

### Java 函数式接口与 C# 委托的区别

## 关于

### 联系我

如果您发现任何错误或有任何建议，请联系我（ryuu）

### 更新计划

补充预设的函数式接口及多播函数式接口

## 注释

[1] C# 中类似这样的后期绑定 ([late binding](https://en.wikipedia.org/wiki/Late_binding))
实现被称为委托 ([delegate](https://docs.microsoft.com/zh-cn/dotnet/csharp/delegate-class))
